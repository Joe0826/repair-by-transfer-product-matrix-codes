#include <unistd.h>
#include <sys/time.h>
#include <time.h>
#include <sys/stat.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <assert.h>

#include "MBR_MSR.h"
#include "product_matrix.h"
#include "rbt.h"
#include "dag_helper.h"
#include "common.h"

int main (int argc, char **argv) {
    FILE *fp;
    CodingTechnique tech;       // coding technique (parameter)
    RbtType rbt = RBT_NONE; // repair-by-transfer type (parameter)
    int n, k,d, w, a, B ;       // PMC parameters

    int fsize;        // original file size
    int msg_size;     // encoded file size (padded)

    /** Creation of file name variables. */
    char fname[256];
    char chunk_fname[256];
    char* code_dir = "coded_files";

    /** Buffers for data and coding matrices. */
    char *msg;
    int  *D;
    int  *G;
    int *lambdas;
    int *psi;
    int *M;

    /* Repair-by-transfer data. */
    int* all_mus;
    int* all_P;
    int* all_P_inv;
    int* nodes_P_idx;

    /** Timing. */
    double t_IO = 0.0;
    double t_coding = 0.0;
    double t_overhead = 0.0;
    clock_t t;

    /* Arguments*/
    if (argc < 2) {
        fprintf(stderr,  "usage: enc_metadata node_id0 [node_id1...] \n\n");
        fprintf(stderr,  "enc_metadata :    path to metadata file generated by encoder\n");
        fprintf(stderr,  "node_ids     :    ids of the participating nodes (space-separated)\n");
        fprintf(stderr,  "                  [if none specified, will use first k]\n");
        fprintf(stderr,  "\n Expects coded chunks in ./%s/ \n", code_dir);
        exit(1);
    }

    /* Open encoder metadata file and parse. */
    fp = fopen(argv[1], "r");
    if (fp == NULL) {
        fprintf(stderr,  "  > Unable to open file.\n");
        exit(1);
    }
    read_meta(fp,
        fname, &fsize, &msg_size,
        &n, &k, &d, &a, &B, &w, &tech, &rbt);
    fclose(fp);

    int nodes[k]; // the participating nodes.
    for (int i = 0; i < k; i++) {
        if(argc > 2)
            nodes[i] = atoi(argv[2+i]);
        else
            nodes[i] = i;
    }

    /* Print metadata. */
    print_meta(fname, fsize, msg_size,
        n, k, d, a, B, w, tech, rbt);

    printf("participating nodes: ");
    for (int i = 0; i < k; i++) {
        printf("%d, ", nodes[i]);
    }
    printf("\n");

    /* Read in all chunks. */
    t = clock();
    char** chunk_ptrs = talloc(char*, k*a);
    int chunk_size = msg_size / B;
    int chunk_idx = 0;
    for (int i = 0; i < k; i++) {
        int ni = nodes[i];

        for (int j = 0; j < a; j++) {
            chunk_ptrs[chunk_idx] = talloc(char, chunk_size);

            read_chunk_file(chunk_ptrs[chunk_idx], chunk_size,
                    code_dir, fname, ni, j);

            chunk_idx++;
        }
    }
    t_IO += clock() - t;


    /* Compute original message into msg. */
    msg = (char*) malloc(msg_size);

    t = clock();
    make_code(tech, n, k, d, w,
        &a, &B, &G, &psi, &lambdas, &M);

    if (rbt != RBT_NONE) {
        /* Prepare RBT data. */
        int* all_mus = make_all_mus(n, k, d, a, w, tech);
        gen_rbt_data(&all_P, &all_P_inv, &nodes_P_idx, all_mus, n, a, w, rbt);
    }

    /*
     * Decoding: Simply invert the steps for encoding.
     *   We encoded as (for MSR):
     *   x --> [RBT-inverse (sys) --> G_sys^{-1}] --> { G_dc --> RBT (dc) }
     *
     *   For MBR:
     *   x --> [Q (rbt-precode)] --> { G_dc --> RBT (dc) }
     *
     * Below, dc_dag inverts {...}, ie the encoding
     *        recode_dag inverts [...], ie the precoding
     *
     *        rbt_decode inverts RBT (dc)
     */

    GeneratorDAG* rbt_decode = NULL;
    GeneratorDAG* recode_dag = NULL;

    // Setup inverse-precoding (recode_dag) and RBT data.
    if (rbt != RBT_NONE) {
        int* sys_nodes = range(0, k);
        rbt_decode = rbt_decode_dc(all_P_inv, nodes, k, a, w);

        if (tech == MSR) {
            GeneratorDAG* sys_recode = make_transform_dag(NULL, G, B, "sys_recode"); // ka = B for MSR
            GeneratorDAG* rbt_recode = rbt_shuffle(all_P, sys_nodes, k, a, w, "rbt_recode"); // inverts RBT-inverse (sys)
            recode_dag = concat_dag(sys_recode, rbt_recode);
        } else {
            int* Q = make_rbt_precoder_matrix(all_P, nodes_P_idx, G, k, a, B, w);
            int* Q_inv = talloc(int, B*B);
            invert_matrix(Q, Q_inv, B, w);
            recode_dag = make_transform_dag(NULL, Q_inv, B, "inverse_MBR_precode");
        }
    } else {
        if (tech == MSR) {
            GeneratorDAG* sys_recode = make_transform_dag(NULL, G, B, "sys_recode");
            recode_dag = sys_recode;
        } else {
            recode_dag = NULL;
        }
    }

    GeneratorDAG* dc_dag;
    if (tech == MSR) {
        dc_dag = make_MSR_decoder_dag(psi, lambdas, M, nodes, k, d, w);
    } else {
        dc_dag = make_MBR_decoder_dag(psi, M, nodes, k, d, w);
    }
    dc_dag = concat_dag(rbt_decode, dc_dag); // First RBT-decode, then normal DC.

    // Compose the full decoder DAG (DC, then recode).
    GeneratorDAG* full_dc_dag = concat_dag(dc_dag, recode_dag);
    t_overhead += clock()-t;

    t = clock();
    // TODO: use buffered version
    apply_data_collect_dag_striped(full_dc_dag, chunk_ptrs, msg, k, a, B, msg_size, w);
    t_coding += clock()-t;

    /* Save into file. */
    t = clock();
    dprintf("*** Writing decoded file: %s\n", fname);
    FILE* fmsg = fopen(fname, "wb");
    fwrite(msg, 1, fsize, fmsg);
    fclose(fmsg);
    t_IO += clock() - t;

    /* Print stats. */
    printf("Bytes read       : %d\n", chunk_size*k*a);
    printf("Bytes written    : %d\n", fsize);
    printf("Overhead [s]     : %.5f\n",t_overhead/CLOCKS_PER_SEC);
    printf("Coding Time [s]  : %.5f\n",t_coding/CLOCKS_PER_SEC);
    printf("IO Time [s]      : %.5f\n",t_IO/CLOCKS_PER_SEC);

    /* Free allocated memory */
    for(int i = 0; i < k*a; i++)
        free(chunk_ptrs[i]);
    free(chunk_ptrs);
    free(msg);
}
