#include <unistd.h>
#include <sys/time.h>
#include <time.h>
#include <sys/stat.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>

#include "MBR_MSR.h"
#include "matrix.h"
#include "product_matrix.h"
#include "rbt.h"
#include "common.h"

int main (int argc, char **argv) {
    FILE *fp;
    CodingTechnique tech;   // coding technique (parameter)
    RbtType rbt;            // repair-by-transfer type (parameter)
    int n, k, d, w, a, B;   // PMC parameters
    int f;                  // the index of the failed node (to help/fix).
    int msg_size;  // original file size
    int fsize;     // encoded file size (padded)

    /** Creation of file name variables. */
    char fname[256];
    char chunk_fname[256];
    char* code_dir = "coded_files";
    char* helper_dir = "helper_files";

    /** Buffers. */
    int* mu_f;
    int* orig_mu_f;

    int  *G;
    int *lambdas;
    int *psi;
    int *M;

    const int buffsize = 16384; //16K

    /* Repair-by-transfer data. */
    int* all_mus;
    int* all_P;
    int* all_P_inv;
    int* nodes_P_idx;

    /** Timing. */
    double t_IO = 0.0;
    double t_coding = 0.0;
    double t_overhead = 0.0;
    clock_t t;

	struct timeval tv1, tv2, tv3;

    /* Arguments*/
    if (argc < 5) {    // inputfile n k d
        fprintf(stderr,  "usage: {help/fix} f enc_metadata [helper_id0 helper_id1...]\n");
        fprintf(stderr,  "f            :    id of failed node.\n");
        fprintf(stderr,  "enc_metadata :    path to metadata file generated by encoder\n");
        fprintf(stderr,  "helper_ids   :    helper node ids \n");
        fprintf(stderr,  "                  (to generate chunks for in case of HELP,\n");
        fprintf(stderr,  "                   or use chunks from in case of FIX\n");
        fprintf(stderr,  "  Help: Expects coded chunks in ./%s/ \n", code_dir);
        fprintf(stderr,  "  Fix: Expects helper chunks in ./%s/ \n", helper_dir);
        exit(1);
    }
    sscanf(argv[2], "%d", &f);


    /* Open encoder metadata file and parse. */
    fp = fopen(argv[3], "r");
    if (fp == NULL) {
        fprintf(stderr,  "  > Unable to open file.\n");
        exit(1);
    }
    read_meta(fp,
        fname, &fsize, &msg_size,
        &n, &k, &d, &a, &B, &w, &tech, &rbt);
    fclose(fp);

    /* Print metadata. */
    print_meta(fname, fsize, msg_size,
        n, k, d, a, B, w, tech, rbt);

    t = clock();
    orig_mu_f = make_mu(f, k, d, a, w, tech);
    if (rbt != RBT_NONE) {
        /* Prepare RBT data. */
        int* all_mus = make_all_mus(n, k, d, a, w, tech);
        gen_rbt_data(&all_P, &all_P_inv, &nodes_P_idx, all_mus, n, a, w, rbt);
    }
    t_overhead += clock() - t;

    int chunk_size = msg_size / B;

    /* Read in helper-node indices. */
    int num_helpers = argc - 4;
    int helper_nodes[num_helpers];
    for (int i = 0; i < num_helpers; i++) {
        helper_nodes[i] = atoi(argv[4 + i]);
    }
    printf("helper nodes: ");
    for (int i = 0; i < num_helpers; i++) {
        printf("%d, ", helper_nodes[i]);
    }
    printf("\n");

    if (strcmp(argv[1], "help") == 0) {
        /* Create helper directory */
        int i = mkdir(helper_dir, S_IRWXU);
        if (i == -1 && errno != EEXIST) {
            fprintf(stderr, "  > Unable to create %s directory.\n", helper_dir);
            exit(1);
        }

        /* Allocate for stored-chunks. */

        /* Encode helper-chunk for each helper. */
        for (int hnum = 0; hnum < num_helpers; hnum++) {
            int h_id = helper_nodes[hnum];
            int idx = get_repair_chunk_idx(h_id, f, n, a, rbt);

            sprintf(chunk_fname, "%s/%s_helper_chunk_from%d_to%d", helper_dir, fname, h_id, f);
            unlink(chunk_fname); // rm existing link, if any
            // to avoid the following DANGEROUS situation:
            // helper_chunk --> coded_file
            // write to helper_chunk... actually writes to coded_file!
            if (idx >= 0) {
                // We have the exact repair chunk, can just symlink it.
                printf("*** REPAIR BY TRANSFER chunk from node %d to failed node %d...\n", h_id, f);

                t = clock();
                char stored_chunk_fname[256];
                // we need the SOURCE path (in coded_files) to be relative to the TARGET path (helper_files)
                // hence the leading '../'
                sprintf(stored_chunk_fname, "../%s/%s_node%d_sym%d", code_dir, fname, h_id, idx);
                int err = symlink(stored_chunk_fname, chunk_fname);
                if (err != 0) {
                    fprintf(stderr,  "  > Unable to symlink helper chunk. ERRNO: %d", errno);
                    exit(1);
                }
                t_IO += clock() - t;
            } else {
                // Need to compute the repair chunk.
                printf("*** Generating repair chunk from node %d to failed node %d...\n", h_id, f);

                char** chunk_ptrs = talloc(char*, a);
                for (int i = 0; i < a; i++)
                    chunk_ptrs[i] = talloc(char, chunk_size);
                /* Allocate for helper-chunk. */
                char* helper_chunk = talloc(char, chunk_size);

                /* Read in all stored chunks. */
                t = clock();
                for (int i = 0; i < a; i++) {
                    read_chunk_file(chunk_ptrs[i], chunk_size,
                            code_dir, fname, h_id, i);
                }
                t_IO += clock() - t;

                /* Compute helper-chunk. */
                if (rbt != RBT_NONE) {
                    // Mofidy mu_f for RBT.
                    int* P_inv = all_P_inv + (a*a)*nodes_P_idx[h_id];
                    mu_f = rbt_mu_f(orig_mu_f, P_inv, a, w);
                } else {
                    mu_f = orig_mu_f;
                }
                gettimeofday(&tv1, NULL);
                helper_symbol_striped(chunk_ptrs, mu_f, helper_chunk, a, B, msg_size, w);
                gettimeofday(&tv2, NULL);
                t_coding += tv2.tv_sec - tv1.tv_sec + (tv2.tv_usec - tv1.tv_usec) / 1000000.0;

                /* Save into file. */
                t = clock();
                dprintf("writing helper chunk: %s\n", chunk_fname);
                FILE* fchunk = fopen(chunk_fname, "wb");
                fwrite(helper_chunk, 1, chunk_size, fchunk);
                fclose(fchunk);
                t_IO += clock() - t;

                /* Free. */
                free(helper_chunk);
                for(int i = 0; i < a; i++)
                    free(chunk_ptrs[i]);
                free(chunk_ptrs);
            }

        }

        /* Print stats. */
        printf("Bytes read       : %d\n", chunk_size*a  * num_helpers);
        printf("Bytes written    : %d\n", chunk_size    * num_helpers);
        printf("Overhead [s]     : %.5f\n",t_overhead/CLOCKS_PER_SEC);
        printf("Coding Time [s]  : %.10f\n",t_coding);
        printf("IO Time [s]      : %.5f\n",t_IO/CLOCKS_PER_SEC);

    } else if (strcmp(argv[1], "fix") == 0) {
        if (num_helpers != d) {
            fprintf(stderr,  "  > Must specify exactly d=%d helper node ids\n", d);
            exit(1);
        }

        printf("*** Repairing failed node %d...\n", f);

        /* Create coded directory */
        int i = mkdir(code_dir, S_IRWXU);
        if (i == -1 && errno != EEXIST) {
            fprintf(stderr, "  > Unable to create %s directory.\n", code_dir);
            exit(1);
        }

        /* Read in all recieved helper-chunks. */
        t = clock();
        char** helper_chunks = talloc(char*, d);
        int chunk_size = msg_size / B;
        for (int i = 0; i < d; i++) {
            helper_chunks[i] = talloc(char, chunk_size);

            sprintf(chunk_fname, "%s/%s_helper_chunk_from%d_to%d", helper_dir, fname, helper_nodes[i], f);
            dprintf("reading chunk: %s\n", chunk_fname);
            FILE* fchunk = fopen(chunk_fname, "rb");
            if (fchunk == NULL) {
                fprintf(stderr,  "  > Unable to open chunk file: %s\n", chunk_fname);
                exit(1);
            }
            fread(helper_chunks[i], 1, chunk_size, fchunk);
            fclose(fchunk);
        }
        t_IO += clock() - t;


        /* Compute repaired chunks. */
        t = clock();
        make_code(tech, n, k, d, w,
            &a, &B, &G, &psi, &lambdas, &M);
        int* A = make_repair_matrix(G, d, a, B, f, orig_mu_f, helper_nodes, w);

        char** repaired_data_ptrs = talloc(char*, a);
        for (int i = 0; i < a; i++) {
            repaired_data_ptrs[i] = talloc(char, chunk_size);
        }

        if (rbt != RBT_NONE) {
            int* Pf = all_P + (a*a)*f;
            // First repair as usual, then rbt-postcode: A = Pf * A_orig
            int* A_rbt = talloc(int, a * d);
            matrix_multiply(A_rbt, Pf, A, a, a, a, d, w);
            A = A_rbt;
        }
        t_overhead += clock() - t;

        gettimeofday(&tv1, NULL);
        //repair_striped(helper_chunks, A, repaired_data_ptrs, d, a, B, msg_size, w);
        matrix_data_product_buff(A, d, a,
                helper_chunks, repaired_data_ptrs, chunk_size,
                w, buffsize);
        gettimeofday(&tv2, NULL);
        t_coding += tv2.tv_sec - tv1.tv_sec + (tv2.tv_usec - tv1.tv_usec) / 1000000.0;

        /* Write to alpha files. */
        t = clock();
        for (int j = 0; j < a; j++) {
            sprintf(chunk_fname, "%s/%s_node%d_sym%d", code_dir, fname, f, j);
            dprintf("writing repaired chunk: %s\n", chunk_fname);
            FILE* fchunk = fopen(chunk_fname, "wb");
            fwrite(repaired_data_ptrs[j], 1, chunk_size, fchunk);
            fclose(fchunk);
        }
        t_IO += clock() - t;

        /* Print stats. */
        printf("Bytes read       : %d\n", chunk_size*d);
        printf("Bytes written    : %d\n", chunk_size*a);
        printf("Overhead [s]     : %.5f\n",t_overhead/CLOCKS_PER_SEC);
        printf("Coding Time [s]  : %.10f\n",t_coding);
        printf("IO Time [s]      : %.5f\n",t_IO/CLOCKS_PER_SEC);

        /* Free. */
        for(int i = 0; i < d; i++)
            free(helper_chunks[i]);
        free(helper_chunks);
        for(int i = 0; i < a; i++)
            free(repaired_data_ptrs[i]);
        free(repaired_data_ptrs);
        free(G);
        free(A);
    } else {
        fprintf(stderr,  "  > Not a valid operation. Choose one of the following: {help, fix}.\n");
        exit(1);
    }


    /* Free allocated memory */
    // TODO.
}
